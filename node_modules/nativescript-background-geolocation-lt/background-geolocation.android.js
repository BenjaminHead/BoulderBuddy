"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var background_geolocation_common_1 = require("./background-geolocation.common");
var permissions = require("nativescript-permissions");
var app = require("application");
var TSCallback = com.transistorsoft.locationmanager.adapter.callback.TSCallback;
var TSLocationCallback = com.transistorsoft.locationmanager.adapter.callback.TSLocationCallback;
var TSLocation = com.transistorsoft.locationmanager.location.TSLocation;
var TSPlayServicesConnectErrorCallback = com.transistorsoft.locationmanager.adapter.callback.TSPlayServicesConnectErrorCallback;
var TSSyncCallback = com.transistorsoft.locationmanager.adapter.callback.TSSyncCallback;
var TSGetLocationsCallback = com.transistorsoft.locationmanager.adapter.callback.TSGetLocationsCallback;
var TSGetCountCallback = com.transistorsoft.locationmanager.adapter.callback.TSGetCountCallback;
var TSInsertLocationCallback = com.transistorsoft.locationmanager.adapter.callback.TSInsertLocationCallback;
var TSGetGeofencesCallback = com.transistorsoft.locationmanager.adapter.callback.TSGetGeofencesCallback;
var TSGetLogCallback = com.transistorsoft.locationmanager.adapter.callback.TSGetLogCallback;
var TSEmailLogCallback = com.transistorsoft.locationmanager.adapter.callback.TSEmailLogCallback;
var TSActivityChangeCallback = com.transistorsoft.locationmanager.adapter.callback.TSActivityChangeCallback;
var TSHttpResponseCallback = com.transistorsoft.locationmanager.adapter.callback.TSHttpResponseCallback;
var TSGeofenceCallback = com.transistorsoft.locationmanager.adapter.callback.TSGeofenceCallback;
var TSGeofencesChangeCallback = com.transistorsoft.locationmanager.adapter.callback.TSGeofencesChangeCallback;
var TSHeartbeatCallback = com.transistorsoft.locationmanager.adapter.callback.TSHeartbeatCallback;
var TSLocationProviderChangeCallback = com.transistorsoft.locationmanager.adapter.callback.TSLocationProviderChangeCallback;
var TSScheduleCallback = com.transistorsoft.locationmanager.adapter.callback.TSScheduleCallback;
var TSPowerSaveChangeCallback = com.transistorsoft.locationmanager.adapter.callback.TSPowerSaveChangeCallback;
var TSSensors = com.transistorsoft.locationmanager.util.Sensors;
var TAG = "TSLocationnManager";
var REQUEST_ACTION_START = 1;
var REQUEST_ACTION_GET_CURRENT_POSITION = 2;
var REQUEST_ACTION_START_GEOFENCES = 3;
var emptyFn = function () { };
// Inform adapter.BackgroundGeolocation when Activity is destroyed.
app.android.on(app.AndroidApplication.activityDestroyedEvent, function (args) {
    BackgroundGeolocation.onActivityDestroyed(args);
});
var BackgroundGeolocation = (function (_super) {
    __extends(BackgroundGeolocation, _super);
    function BackgroundGeolocation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BackgroundGeolocation.onActivityDestroyed = function (args) {
        this.getAdapter().onActivityDestroy();
        this.intent = null;
    };
    BackgroundGeolocation.addListener = function (event, success, failure) {
        if (typeof (event) === 'object') {
            for (var key in event) {
                this.addListener(key, event[key]);
            }
            return;
        }
        if (this.events.indexOf(event) < 0) {
            throw "Invalid event: " + event;
        }
        failure = failure || emptyFn;
        var cb;
        switch (event) {
            case 'location':
                cb = this.createLocationCallback(success, failure);
                this.getAdapter().onLocation(cb);
                break;
            case 'motionchange':
                cb = this.createMotionChangeCallback(success);
                this.getAdapter().onMotionChange(cb);
                break;
            case 'activitychange':
                cb = this.createActivityChangeCallback(success);
                this.getAdapter().onActivityChange(cb);
                break;
            case 'http':
                cb = this.createHttpCallback(success, failure);
                this.getAdapter().onHttp(cb);
                break;
            case 'geofence':
                cb = this.createGeofenceCallback(success);
                this.getAdapter().onGeofence(cb);
                break;
            case 'geofenceschange':
                cb = this.createGeofencesChangeCallback(success);
                this.getAdapter().onGeofencesChange(cb);
                break;
            case 'schedule':
                cb = this.createScheduleCallback(success);
                this.getAdapter().onSchedule(cb);
                break;
            case 'heartbeat':
                cb = this.createHeartbeatCallback(success);
                this.getAdapter().onHeartbeat(cb);
                break;
            case 'providerchange':
                cb = this.createProviderChangeCallback(success);
                this.getAdapter().onLocationProviderChange(cb);
                break;
            case 'powersavechange':
                cb = this.createPowerSaveChangeCallback(success);
                this.getAdapter().onPowerSaveChange(cb);
                break;
        }
        if (cb) {
            this.registerCallback(event, success, cb);
        }
    };
    BackgroundGeolocation.removeNativeListener = function (event, callback) {
        this.getAdapter().removeListener(event, callback);
    };
    /**
    * Configuration Methods
    */
    BackgroundGeolocation.configure = function (config, success, failure) {
        var adapter = this.getAdapter();
        var callback = new TSCallback({
            onSuccess: function () {
                success(JSON.parse(adapter.getState().toString()));
            },
            onError: function (error) {
                failure(error);
            }
        });
        adapter.configure(new org.json.JSONObject(JSON.stringify(config)), callback);
    };
    BackgroundGeolocation.setConfig = function (config, success, failure) {
        var adapter = this.getAdapter();
        failure = failure || emptyFn;
        success = success || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success(JSON.parse(adapter.getState().toString()));
            },
            onError: function (error) {
                failure(error);
            }
        });
        adapter.setConfig(new org.json.JSONObject(JSON.stringify(config)), callback);
    };
    BackgroundGeolocation.getState = function (success) {
        success(JSON.parse(this.getAdapter().getState().toString()));
    };
    /**
    * Tracking Methods
    */
    BackgroundGeolocation.start = function (success, failure) {
        var _this = this;
        success = success || emptyFn;
        failure = failure || emptyFn;
        if (this.hasPermission()) {
            this.setEnabled(true, success, failure);
        }
        else {
            this.requestPermission(function () {
                _this.setEnabled(true, success, failure);
            }, function () {
                console.log('- requestPermission failure');
            });
        }
    };
    BackgroundGeolocation.stop = function (success, failure) {
        success = success || emptyFn;
        var adapter = this.getAdapter();
        adapter.stop(new TSCallback({
            onSuccess: function () {
                success(JSON.parse(adapter.getState().toString()));
            },
            onFailure: function (error) {
                failure(error);
            }
        }));
    };
    BackgroundGeolocation.changePace = function (value, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var adapter = this.getAdapter();
        var cb = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        adapter.changePace(value, cb);
    };
    BackgroundGeolocation.startSchedule = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        if (this.getAdapter().startSchedule()) {
            this.getState(success);
        }
        else {
            failure("Failed to start schedule.  Did you configure a #schedule?");
        }
    };
    BackgroundGeolocation.stopSchedule = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        this.getAdapter().stopSchedule();
        this.getState(success);
    };
    BackgroundGeolocation.startGeofences = function (success, failure) {
        var _this = this;
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        if (this.hasPermission()) {
            this.getAdapter().startGeofences(callback);
        }
        else {
            this.requestPermission(function () {
                _this.getAdapter().startGeofences(callback);
            }, function () {
                failure('Permission denied');
            });
        }
    };
    BackgroundGeolocation.getCurrentPosition = function (success, failure, options) {
        failure = failure || emptyFn;
        options = options || {};
        var callback = new TSLocationCallback({
            onLocation: function (tsLocation) {
                success(JSON.parse(tsLocation.toJson().toString()));
            },
            onError: function (error) {
                failure(error);
            }
        });
        this.getAdapter().getCurrentPosition(new org.json.JSONObject(JSON.stringify(options)), callback);
    };
    BackgroundGeolocation.watchPosition = function (success, failure, options) {
        failure = failure || emptyFn;
        options = options || {};
        var callback = new TSLocationCallback({
            onLocation: function (tsLocation) {
                success(JSON.parse(tsLocation.toJson().toString()));
            },
            onError: function (error) {
                failure(error);
            }
        });
        this.getAdapter().watchPosition(new org.json.JSONObject(JSON.stringify(options)), callback);
    };
    BackgroundGeolocation.stopWatchPosition = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onError: function (error) {
                failure(error);
            }
        });
        this.getAdapter().stopWatchPosition(callback);
    };
    BackgroundGeolocation.getOdometer = function (success, failure) {
        success(this.getAdapter().getOdometer());
    };
    BackgroundGeolocation.setOdometer = function (value, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSLocationCallback({
            onLocation: function (tsLocation) {
                success(JSON.parse(tsLocation.toJson().toString()));
            },
            onError: function (error) {
                failure(error);
            }
        });
        if (this.hasPermission()) {
            this.getAdapter().setOdometer(new java.lang.Float(value), callback);
        }
        else {
            this.requestPermission(function () {
                this.getAdapter().setOdometer(new java.lang.Float(value), callback);
            }.bind(this), function () {
                console.log('- requestPermission failure');
            }.bind(this));
        }
    };
    BackgroundGeolocation.resetOdometer = function (success, failure) {
        this.setOdometer(0, success, failure);
    };
    /**
    * HTTP & Persistence Methods
    */
    BackgroundGeolocation.sync = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSSyncCallback({
            onSuccess: function (records) {
                var size = records.size();
                var result = [];
                for (var i = 0; i < size; i++) {
                    var record = records.get(i);
                    result.push(JSON.parse(record.json.toString()));
                }
                success(result);
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().sync(callback);
    };
    BackgroundGeolocation.getLocations = function (success, failure) {
        failure = failure || emptyFn;
        var callback = new TSGetLocationsCallback({
            onSuccess: function (records) {
                var size = records.size();
                var result = [];
                for (var i = 0; i < size; i++) {
                    var record = records.get(i);
                    result.push(JSON.parse(record.json.toString()));
                }
                success(result);
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().getLocations(callback);
    };
    BackgroundGeolocation.getCount = function (success) {
        var callback = new TSGetCountCallback({
            onSuccess: function (count) {
                success(count);
            },
            onFailure: function (error) {
                console.warn('Failed to getCount: ', error);
            }
        });
        this.getAdapter().getCount(callback);
    };
    BackgroundGeolocation.insertLocation = function (data, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSInsertLocationCallback({
            onSuccess: function (uuid) {
                success(uuid);
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().insertLocation(new org.json.JSONObject(JSON.stringify(data)), callback);
    };
    // @deprecated
    BackgroundGeolocation.clearDatabase = function (success, failure) {
        this.destroyLocations(success, failure);
    };
    BackgroundGeolocation.destroyLocations = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().destroyLocations(callback);
    };
    /**
    * Geofencing Methods
    */
    BackgroundGeolocation.addGeofence = function (params, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().addGeofence(new org.json.JSONObject(JSON.stringify(params)), callback);
    };
    BackgroundGeolocation.removeGeofence = function (identifier, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().removeGeofence(identifier, callback);
    };
    BackgroundGeolocation.addGeofences = function (geofences, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        geofences = geofences || [];
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().addGeofences(new org.json.JSONArray(JSON.stringify(geofences)), callback);
    };
    BackgroundGeolocation.removeGeofences = function (geofences, success, failure) {
        // Handle case where no geofences are provided (ie: remove all geofences).
        if (typeof (geofences) === 'function') {
            failure = success;
            success = geofences;
            geofences = [];
        }
        geofences = geofences || [];
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        var identifiers = new java.util.ArrayList();
        geofences.forEach(function (identifier) { identifiers.add(identifier); });
        this.getAdapter().removeGeofences(identifiers, callback);
    };
    BackgroundGeolocation.getGeofences = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSGetGeofencesCallback({
            onSuccess: function (records) {
                var size = records.size();
                var result = [];
                for (var i = 0; i < size; i++) {
                    var geofence = records.get(i);
                    result.push(JSON.parse(geofence.toJson()));
                }
                success(result);
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().getGeofences(callback);
    };
    /**
    * Logging & Debug methods
    */
    BackgroundGeolocation.getLog = function (success, failure) {
        failure = failure || emptyFn;
        var callback = new TSGetLogCallback({
            onSuccess: function (log) {
                success(log);
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().getLog(callback);
    };
    BackgroundGeolocation.emailLog = function (email, success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSEmailLogCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().emailLog(email, app.android.foregroundActivity, callback);
    };
    BackgroundGeolocation.destroyLog = function (success, failure) {
        success = success || emptyFn;
        failure = failure || emptyFn;
        var callback = new TSCallback({
            onSuccess: function () {
                success();
            },
            onFailure: function (error) {
                failure(error);
            }
        });
        this.getAdapter().destroyLog(callback);
    };
    BackgroundGeolocation.getSensors = function (success, failure) {
        failure = failure || emptyFn;
        var sensors = TSSensors.getInstance(app.android.context);
        var result = {
            "platform": "android",
            "accelerometer": sensors.hasAccelerometer(),
            "magnetometer": sensors.hasMagnetometer(),
            "gyroscope": sensors.hasGyroscope(),
            "significant_motion": sensors.hasSignificantMotion()
        };
        success(result);
    };
    BackgroundGeolocation.isPowerSaveMode = function (success, failure) {
        var isPowerSaveMode = this.getAdapter().isPowerSaveMode().booleanValue();
        success(isPowerSaveMode);
    };
    BackgroundGeolocation.startBackgroundTask = function (success) {
        // Just return 0 for compatibility with iOS API.  Android has no concept of these iOS-only background-tasks.
        success(0);
    };
    BackgroundGeolocation.finish = function (taskId) {
        // Just an empty function for compatibility with iOS.  Android has no concept of these iOS-only background-tasks.
    };
    BackgroundGeolocation.playSound = function (soundId) {
        com.transistorsoft.locationmanager.adapter.BackgroundGeolocation.startTone(soundId);
    };
    /**
    * Private
    */
    BackgroundGeolocation.setEnabled = function (value, success, failure) {
        var adapter = this.getAdapter();
        if (value) {
            var callback = new TSCallback({
                onSuccess: function () {
                    success(JSON.parse(adapter.getState().toString()));
                },
                onFailure: function (error) {
                    failure(error);
                }
            });
            adapter.start(callback);
        }
    };
    BackgroundGeolocation.createLocationCallback = function (success, failure) {
        failure = failure || emptyFn;
        return new TSLocationCallback({
            onLocation: function (tsLocation) {
                success(JSON.parse(tsLocation.toJson().toString()));
            },
            onError: function (error) {
                failure(error);
            }
        });
    };
    BackgroundGeolocation.createMotionChangeCallback = function (callback) {
        return new TSLocationCallback({
            onLocation: function (tsLocation) {
                var isMoving = tsLocation.getIsMoving().booleanValue();
                callback(isMoving, JSON.parse(tsLocation.toJson().toString()));
            },
            onError: function (error) {
            }
        });
    };
    BackgroundGeolocation.createHttpCallback = function (success, failure) {
        return new TSHttpResponseCallback({
            onHttpResponse: function (response) {
                var params = {
                    status: response.status,
                    responseText: response.responseText
                };
                if (response.isSuccess()) {
                    success(params);
                }
                else {
                    failure(params);
                }
            }
        });
    };
    BackgroundGeolocation.createActivityChangeCallback = function (callback) {
        return new TSActivityChangeCallback({
            onActivityChange: function (event) {
                callback(JSON.parse(event.toJson().toString()));
            }
        });
    };
    BackgroundGeolocation.createGeofenceCallback = function (callback) {
        return new TSGeofenceCallback({
            onGeofence: function (event) {
                callback(JSON.parse(event.toJson().toString()));
            }
        });
    };
    BackgroundGeolocation.createGeofencesChangeCallback = function (callback) {
        return new TSGeofencesChangeCallback({
            onGeofencesChange: function (event) {
                callback(JSON.parse(event.toJson().toString()));
            }
        });
    };
    BackgroundGeolocation.createScheduleCallback = function (callback) {
        return new TSScheduleCallback({
            onSchedule: function (event) {
                callback(JSON.parse(event.toJson().toString()));
            }
        });
    };
    BackgroundGeolocation.createProviderChangeCallback = function (callback) {
        return new TSLocationProviderChangeCallback({
            onLocationProviderChange: function (event) {
                callback(JSON.parse(event.toJson().toString()));
            }
        });
    };
    BackgroundGeolocation.createHeartbeatCallback = function (callback) {
        return new TSHeartbeatCallback({
            onHeartbeat: function (event) {
                callback(JSON.parse(event.toJson().toString()));
            }
        });
    };
    BackgroundGeolocation.createPowerSaveChangeCallback = function (callback) {
        return new TSPowerSaveChangeCallback({
            onPowerSaveChange: function (isPowerSaveMode) {
                callback(isPowerSaveMode.booleanValue());
            }
        });
    };
    BackgroundGeolocation.init = function () {
        var _this = this;
        this.intent = app.android.startActivity.getIntent();
        // Handle Google Play Services errors
        this.getAdapter().onPlayServicesConnectError(new TSPlayServicesConnectErrorCallback({
            onPlayServicesConnectError: function (errorCode) {
                _this.handleGooglePlayServicesConnectError(errorCode);
            }
        }));
        this.logger = new background_geolocation_common_1.Logger(com.transistorsoft.locationmanager.logger.TSLog);
    };
    BackgroundGeolocation.getIntent = function () {
        var activity = (app.android.foregroundActivity) ? app.android.foregroundActivity : app.android.startActivity;
        return (activity) ? activity.getIntent() : this.intent;
    };
    BackgroundGeolocation.getAdapter = function () {
        if (!this.intent) {
            this.init();
        }
        return com.transistorsoft.locationmanager.adapter.BackgroundGeolocation.getInstance(app.android.context, this.getIntent());
    };
    BackgroundGeolocation.handleGooglePlayServicesConnectError = function (errorCode) {
        com.google.android.gms.common.GoogleApiAvailability.getInstance().getErrorDialog(app.android.foregroundActivity, errorCode, 1001).show();
    };
    BackgroundGeolocation.hasPermission = function () {
        var result = android.os.Build.VERSION.SDK_INT < 23;
        if (!result) {
            result = ((permissions.hasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION))
                && (permissions.hasPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION)));
        }
        return result;
    };
    BackgroundGeolocation.requestPermission = function (success, failure) {
        permissions.requestPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, "Background tracking required").then(success).catch(failure);
    };
    return BackgroundGeolocation;
}(background_geolocation_common_1.AbstractBackgroundGeolocation));
exports.BackgroundGeolocation = BackgroundGeolocation;
